function [ellip,std_e] = c2FromEllip(t2_array,ellipticityStruct)
% [c2, c2_std] = c2FromEllip(t2_array,ellipticityStruct)
%
% This function requires an input of an array of population times (t2), and
% an ellipticity structure similar to the one generated by 'fitEllip.m.'
% Specifically, it is important that (1) you named the widths sD
% (diagonal) and sA (antidiagonal) in your function. Your ellipticity
% structure should be in the same order as your t2 array (sorted by t2).
% 
% The returns of this function will be arrays of ellipticities (~two-point
% correlations) and their standard deviations, for each population time.

ellip = zeros(size(t2_array));
std_e = zeros(size(t2_array));
for ii = 1:length(ellipticityStruct)
  dummy = confint(ellipticityStruct(ii).fitresult);
  
  % This section dynamically finds the indices of the sD and sA
  % coefficients in your fit.
  dummy_coeff_names = coeffnames(ellipticityStruct(ii).fitresult);
  DiagonalIndex = ~cellfun('isempty',strfind(dummy_coeff_names, 'sD'));
  AntiDiagonalIndex = ~cellfun('isempty',strfind(dummy_coeff_names, 'sA'));
  
  err_sD = dummy(:,DiagonalIndex);
  err_sA = dummy(:,AntiDiagonalIndex);
  std_sD = (err_sD(2) - err_sD(1))/2; %std of sD
  std_sA = (err_sA(2) - err_sA(1))/2; %std of sA
  sD = ellipticityStruct(ii).fitresult.sD;
  sA = ellipticityStruct(ii).fitresult.sA;
  de_sD = (4*sD*sA^2)/(sD^2+sA^2)^2; %derivatives for sD
  de_sA = -(4*sD^2*sA)/(sD^2+sA^2)^2; %derivatives for sA
  ellip(ii) = (sD.^2-sA.^2)./(sD.^2+sA.^2);
  std_e(ii) = (de_sD.^2*std_sD.^2 + de_sA.^2*std_sA.^2)^0.5;
end